/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.gtnewhorizons.gtnhgradle;

import com.diffplug.blowdryer.Blowdryer;
import com.gtnewhorizons.retrofuturagradle.shadow.com.google.common.collect.ImmutableMap;
import com.gtnewhorizons.gtnhgradle.modules.AccessTransformerModule;
import com.gtnewhorizons.gtnhgradle.modules.CodeStyleModule;
import com.gtnewhorizons.gtnhgradle.modules.GitVersionModule;
import com.gtnewhorizons.gtnhgradle.modules.IdeIntegrationModule;
import com.gtnewhorizons.gtnhgradle.modules.JVMDowngraderModule;
import com.gtnewhorizons.gtnhgradle.modules.MixinModule;
import com.gtnewhorizons.gtnhgradle.modules.ModernJavaModule;
import com.gtnewhorizons.gtnhgradle.modules.OldGradleEmulationModule;
import com.gtnewhorizons.gtnhgradle.modules.PublishingModule;
import com.gtnewhorizons.gtnhgradle.modules.ScalaModule;
import com.gtnewhorizons.gtnhgradle.modules.ShadowModule;
import com.gtnewhorizons.gtnhgradle.modules.StandardScriptsModules;
import com.gtnewhorizons.gtnhgradle.modules.StructureCheckModule;
import com.gtnewhorizons.gtnhgradle.modules.ToolchainModule;
import com.gtnewhorizons.gtnhgradle.modules.UpdaterModule;
import com.gtnewhorizons.gtnhgradle.modules.UtilityModule;
import com.gtnewhorizons.gtnhgradle.modules.WellKnownRepositoriesModule;
import com.gtnewhorizons.retrofuturagradle.UserDevPlugin;
import de.undercouch.gradle.tasks.download.DownloadTaskPlugin;
import org.gradle.api.Project;
import org.gradle.api.Plugin;
import org.gradle.api.file.ArchiveOperations;
import org.gradle.api.file.FileSystemOperations;
import org.gradle.api.file.ProjectLayout;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.gradle.api.model.ObjectFactory;
import org.gradle.api.plugins.ExtensionAware;
import org.gradle.api.plugins.JavaLibraryPlugin;
import org.gradle.api.plugins.PluginManager;
import org.gradle.api.provider.Property;
import org.gradle.api.provider.Provider;
import org.gradle.api.provider.ProviderFactory;
import org.gradle.api.provider.SetProperty;
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin;
import org.gradle.process.ExecOperations;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * The main GTNH buildscript plugin object. You can access it in the buildscript as {@code gtnhGradle} and use it to
 * activate specific modules manually. The GTNH project will use the GTNHConventionPlugin that automatically activates
 * all modules.
 */
public class GTNHGradlePlugin implements Plugin<Project> {

    /**
     * Name of the project extension you can use to
     */
    public static final String PROJECT_EXT_NAME = "gtnhGradle";

    /**
     * Ran by Gradle when the plugin is applied to the project.
     * This applies the Java library and RetroFuturaGradle plugins, for the plugin to do anything else modules need to
     * be opted-in using other functions in this class.
     */
    public void apply(Project project) {
        final PluginManager plugins = project.getPluginManager();

        // Apply shared plugins used by all mods
        plugins.apply(JavaLibraryPlugin.class);
        plugins.apply(MavenPublishPlugin.class);
        plugins.apply(DownloadTaskPlugin.class);
        plugins.apply(UserDevPlugin.class); // RFG

        // Create the gtnhGradle extension as a Gradle DSL-extensible object
        final GTNHExtension gtnh = project.getObjects()
            .newInstance(GTNHExtension.class, project);
        project.getExtensions()
            .add(GTNHExtension.class, PROJECT_EXT_NAME, gtnh);
        if (!gtnh.configuration.blowdryerTag.isEmpty()) {
            // Make blowdryer available in "apply from:" scripts
            project.getExtensions()
                .add(Class.class, "Blowdryer", Blowdryer.class);
        }
    }

    /**
     * The object registered as {@code project.gtnhGradle}
     */
    @SuppressWarnings("unused") // Forms the public API
    public static abstract class GTNHExtension implements ExtensionAware {

        /** Logging service used by the plugin */
        public final @NotNull Logger logger;

        /** Parsed properties associated with this project */
        public @NotNull PropertiesConfiguration configuration;

        /** Lazily computed effective toolchain version */
        private final @NotNull Provider<Integer> effectiveToolchainVersionProvider;

        /** A list of all available modules to activate */
        public static final List<Class<? extends GTNHModule>> ALL_MODULES = List.of( //
            GitVersionModule.class,
            CodeStyleModule.class,
            ToolchainModule.class,
            ScalaModule.class,
            StructureCheckModule.class,
            AccessTransformerModule.class,
            ShadowModule.class,
            UtilityModule.class,
            StandardScriptsModules.AddonScriptModule.class,
            OldGradleEmulationModule.class,
            WellKnownRepositoriesModule.class,
            StandardScriptsModules.RepositoriesScriptModule.class,
            MixinModule.class,
            JVMDowngraderModule.class,
            StandardScriptsModules.DependenciesScriptModule.class,
            ModernJavaModule.class,
            IdeIntegrationModule.class,
            PublishingModule.class,
            UpdaterModule.class,
            StandardScriptsModules.LateAddonScriptModule.class
        //
        );
        /** A map of all available modules, indexed by their class name */
        public static final Map<String, Class<? extends GTNHModule>> MODULES_BY_NAME;

        static {
            final ImmutableMap.Builder<String, Class<? extends GTNHModule>> builder = ImmutableMap.builder();
            for (final Class<? extends GTNHModule> m : ALL_MODULES) {
                builder.put(m.getSimpleName(), m);
            }
            MODULES_BY_NAME = builder.build();
        }

        /**
         * For internal use only.
         *
         * @param project passed in to avoid having to pass the project object to every apply function
         */
        @Inject
        @ApiStatus.Internal
        public GTNHExtension(final Project project) {
            logger = Logging.getLogger(GTNHGradlePlugin.class);
            configuration = PropertiesConfiguration.GradleUtils.makePropertiesFrom(project);

            // Conventions from gradle.properties
            getModernJavaSyntaxMode().convention(ModernJavaSyntaxMode.fromString(configuration.enableModernJavaSyntax));
            getForceToolchainVersion().convention(configuration.forceToolchainVersion);
            getDowngradeTargetVersion().convention(configuration.downgradeTargetVersion);
            getJvmDowngraderMultiReleaseVersions()
                .convention(parseMultiReleaseVersions(configuration.jvmDowngraderMultiReleaseVersions));
            getJvmDowngraderStubsProvider()
                .convention(JvmDowngraderStubsProvider.fromString(configuration.jvmDowngraderStubsProvider));

            effectiveToolchainVersionProvider = createEffectiveToolchainVersionProvider();
        }

        private Provider<Integer> createEffectiveToolchainVersionProvider() {
            return getProviderFactory().provider(() -> {
                final ModernJavaSyntaxMode mode = getModernJavaSyntaxMode().get();
                final int forcedVersion = getForceToolchainVersion().get();
                final Set<Integer> mrVersions = getJvmDowngraderMultiReleaseVersions().get();

                // Find max multi-release version
                int maxMultiReleaseVersion = 0;
                if (mode.usesJvmDowngrader()) {
                    for (int version : mrVersions) {
                        maxMultiReleaseVersion = Math.max(maxMultiReleaseVersion, version);
                    }
                }

                // Compute mode default version
                final int modeDefaultVersion = switch (mode) {
                    case FALSE -> 8;
                    case JABEL -> 17;
                    case JVM_DOWNGRADER, MODERN -> 25;
                };

                if (forcedVersion != -1) {
                    // Validate forced version against jvmDowngraderMultiReleaseVersions
                    if (maxMultiReleaseVersion > forcedVersion) {
                        throw new IllegalArgumentException(
                            "forceToolchainVersion=" + forcedVersion
                                + " is lower than max jvmDowngraderMultiReleaseVersions="
                                + maxMultiReleaseVersion
                                + ". Cannot create Java "
                                + maxMultiReleaseVersion
                                + " bytecode with a Java "
                                + forcedVersion
                                + " toolchain. Either increase forceToolchainVersion or reduce jvmDowngraderMultiReleaseVersions.");
                    }
                    return forcedVersion;
                } else {
                    // Auto toolchain version - use max of mode default and jvmDowngraderMultiReleaseVersions
                    return Math.max(modeDefaultVersion, maxMultiReleaseVersion);
                }
            });
        }

        /**
         * Parses a comma-separated string of Java versions into a Set.
         *
         * @param mrVersionsStr Comma-separated version string (e.g., "21,25")
         * @return Set of parsed version integers
         */
        private static Set<Integer> parseMultiReleaseVersions(String mrVersionsStr) {
            if (mrVersionsStr == null || mrVersionsStr.isEmpty()) {
                return Set.of(21, 25); // Default multi-release versions
            }
            final Set<Integer> versions = new LinkedHashSet<>();
            for (String versionStr : mrVersionsStr.split(",")) {
                try {
                    int version = Integer.parseInt(versionStr.trim());
                    if (version < 9) {
                        throw new IllegalArgumentException(
                            "Invalid jvmDowngraderMultiReleaseVersions entry: " + version + ". Must be >= 9.");
                    }
                    versions.add(version);
                } catch (NumberFormatException e) {
                    throw new IllegalArgumentException(
                        "Invalid jvmDowngraderMultiReleaseVersions: '" + mrVersionsStr
                            + "'. Must be comma-separated integers (e.g., '21' or '21,25').");
                }
            }
            return Set.copyOf(versions);
        }

        /**
         * Activates a module by its class name, if enabled in properties (e.g. {@code GitVersionModule}).
         *
         * @param project The project to activate the module on
         * @param name    Class name of the module, without the package name
         * @throws IllegalArgumentException If the module was not found
         */
        public void applyModuleByName(final Project project, final String name) {
            final Class<? extends GTNHModule> klass = MODULES_BY_NAME.get(name);
            if (klass == null) {
                throw new IllegalArgumentException("Invalid module name " + name);
            }
            GTNHModule.applyIfEnabled(klass, this, project);
        }

        /**
         * Activates all available and enabled modules on the given project.
         *
         * @param project The project to activate the modules on
         */
        public void applyAllModules(final Project project) {
            for (final Class<? extends GTNHModule> moduleClass : ALL_MODULES) {
                GTNHModule.applyIfEnabled(moduleClass, this, project);
            }
        }

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ObjectFactory getObjectFactory();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ProviderFactory getProviderFactory();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ProjectLayout getProjectLayout();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull FileSystemOperations getFileSystemOperations();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ArchiveOperations getArchiveOperations();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ExecOperations getExecOperations();

        // Lazy configuration properties - can be overridden in build.gradle

        /** @return Modern Java syntax mode property */
        public abstract @NotNull Property<ModernJavaSyntaxMode> getModernJavaSyntaxMode();

        /** @return Forced toolchain version override, or -1 to auto-detect */
        public abstract @NotNull Property<Integer> getForceToolchainVersion();

        /** @return Target JVM version for JVM Downgrader (8, 11, or 17) */
        public abstract @NotNull Property<Integer> getDowngradeTargetVersion();

        /** @return Multi-release JAR versions for JVM Downgrader */
        public abstract @NotNull SetProperty<Integer> getJvmDowngraderMultiReleaseVersions();

        /** @return How JVM Downgrader API stubs are provided */
        public abstract @NotNull Property<JvmDowngraderStubsProvider> getJvmDowngraderStubsProvider();

        // Lazy computed providers

        /** @return Lazily computed effective toolchain version */
        public @NotNull Provider<Integer> getEffectiveToolchainVersion() {
            return effectiveToolchainVersionProvider;
        }
    }
}
