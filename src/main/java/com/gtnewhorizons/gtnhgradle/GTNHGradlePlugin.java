/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.gtnewhorizons.gtnhgradle;

import com.diffplug.blowdryer.Blowdryer;
import com.gtnewhorizons.retrofuturagradle.shadow.com.google.common.collect.ImmutableList;
import com.gtnewhorizons.retrofuturagradle.shadow.com.google.common.collect.ImmutableMap;
import com.gtnewhorizons.gtnhgradle.modules.AccessTransformerModule;
import com.gtnewhorizons.gtnhgradle.modules.CodeStyleModule;
import com.gtnewhorizons.gtnhgradle.modules.GitVersionModule;
import com.gtnewhorizons.gtnhgradle.modules.IdeIntegrationModule;
import com.gtnewhorizons.gtnhgradle.modules.MixinModule;
import com.gtnewhorizons.gtnhgradle.modules.ModernJavaModule;
import com.gtnewhorizons.gtnhgradle.modules.OldGradleEmulationModule;
import com.gtnewhorizons.gtnhgradle.modules.PublishingModule;
import com.gtnewhorizons.gtnhgradle.modules.ScalaModule;
import com.gtnewhorizons.gtnhgradle.modules.ShadowModule;
import com.gtnewhorizons.gtnhgradle.modules.StandardScriptsModules;
import com.gtnewhorizons.gtnhgradle.modules.StructureCheckModule;
import com.gtnewhorizons.gtnhgradle.modules.ToolchainModule;
import com.gtnewhorizons.gtnhgradle.modules.UpdaterModule;
import com.gtnewhorizons.gtnhgradle.modules.UtilityModule;
import com.gtnewhorizons.gtnhgradle.modules.WellKnownRepositoriesModule;
import com.gtnewhorizons.retrofuturagradle.UserDevPlugin;
import de.undercouch.gradle.tasks.download.DownloadTaskPlugin;
import org.ajoberstar.grgit.gradle.GrgitPlugin;
import org.gradle.api.Project;
import org.gradle.api.Plugin;
import org.gradle.api.file.ArchiveOperations;
import org.gradle.api.file.FileSystemOperations;
import org.gradle.api.file.ProjectLayout;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.gradle.api.model.ObjectFactory;
import org.gradle.api.plugins.ExtensionAware;
import org.gradle.api.plugins.JavaLibraryPlugin;
import org.gradle.api.plugins.PluginManager;
import org.gradle.api.provider.ProviderFactory;
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin;
import org.gradle.process.ExecOperations;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.util.List;
import java.util.Map;

/**
 * The main GTNH buildscript plugin object. You can access it in the buildscript as {@code gtnhGradle} and use it to
 * activate specific modules manually. The GTNH project will use the GTNHConventionPlugin that automatically activates
 * all modules.
 */
public class GTNHGradlePlugin implements Plugin<Project> {

    /**
     * Name of the project extension you can use to
     */
    public static final String PROJECT_EXT_NAME = "gtnhGradle";

    /**
     * Ran by Gradle when the plugin is applied to the project.
     * This applies the Java library and RetroFuturaGradle plugins, for the plugin to do anything else modules need to
     * be opted-in using other functions in this class.
     */
    public void apply(Project project) {
        final PluginManager plugins = project.getPluginManager();

        // Apply shared plugins used by all mods
        plugins.apply(JavaLibraryPlugin.class);
        plugins.apply(MavenPublishPlugin.class);
        plugins.apply(GrgitPlugin.class);
        plugins.apply(DownloadTaskPlugin.class);
        plugins.apply(UserDevPlugin.class); // RFG

        // Create the gtnhGradle extension as a Gradle DSL-extensible object
        final GTNHExtension gtnh = project.getObjects()
            .newInstance(GTNHExtension.class, project);
        project.getExtensions()
            .add(GTNHExtension.class, PROJECT_EXT_NAME, gtnh);
        if (!gtnh.configuration.blowdryerTag.isEmpty()) {
            // Make blowdryer available in "apply from:" scripts
            project.getExtensions()
                .add(Class.class, "Blowdryer", Blowdryer.class);
        }
    }

    /**
     * The object registered as {@code project.gtnhGradle}
     */
    @SuppressWarnings("unused") // Forms the public API
    public static abstract class GTNHExtension implements ExtensionAware {

        /** Logging service used by the plugin */
        public final @NotNull Logger logger;

        public final @NotNull MinecraftVersion minecraftVersion;

        /** Parsed properties associated with this project */
        public @NotNull PropertiesConfiguration configuration;

        /** A list of all available modules to activate */
        @SuppressWarnings("unchecked") // too long, varargs can't handle generics
        public static final List<Class<? extends GTNHModule>> ALL_MODULES = ImmutableList.of( //
            GitVersionModule.class,
            CodeStyleModule.class,
            ToolchainModule.class,
            ScalaModule.class,
            StructureCheckModule.class,
            AccessTransformerModule.class,
            ShadowModule.class,
            UtilityModule.class,
            StandardScriptsModules.AddonScriptModule.class,
            OldGradleEmulationModule.class,
            WellKnownRepositoriesModule.class,
            StandardScriptsModules.RepositoriesScriptModule.class,
            MixinModule.class,
            StandardScriptsModules.DependenciesScriptModule.class,
            ModernJavaModule.class,
            IdeIntegrationModule.class,
            PublishingModule.class,
            UpdaterModule.class,
            StandardScriptsModules.LateAddonScriptModule.class
        //
        );
        /** A map of all available modules, indexed by their class name */
        public static final Map<String, Class<? extends GTNHModule>> MODULES_BY_NAME;

        static {
            final ImmutableMap.Builder<String, Class<? extends GTNHModule>> builder = ImmutableMap.builder();
            for (final Class<? extends GTNHModule> m : ALL_MODULES) {
                builder.put(m.getSimpleName(), m);
            }
            MODULES_BY_NAME = builder.build();
        }

        /**
         * For internal use only.
         *
         * @param project passed in to avoid having to pass the project object to every apply function
         */
        @Inject
        @ApiStatus.Internal
        public GTNHExtension(final Project project) {
            logger = Logging.getLogger(GTNHGradlePlugin.class);
            configuration = PropertiesConfiguration.GradleUtils.makePropertiesFrom(project);
            minecraftVersion = MinecraftVersion.getByVersionString(configuration.minecraftVersion);
        }

        /**
         * Activates a module by its class name, if enabled in properties (e.g. {@code GitVersionModule}).
         *
         * @param project The project to activate the module on
         * @param name    Class name of the module, without the package name
         * @throws IllegalArgumentException If the module was not found
         */
        public void applyModuleByName(final Project project, final String name) {
            final Class<? extends GTNHModule> klass = MODULES_BY_NAME.get(name);
            if (klass == null) {
                throw new IllegalArgumentException("Invalid module name " + name);
            }
            GTNHModule.applyIfEnabled(klass, this, project);
        }

        /**
         * Activates all available and enabled modules on the given project.
         *
         * @param project The project to activate the modules on
         */
        public void applyAllModules(final Project project) {
            for (final Class<? extends GTNHModule> moduleClass : ALL_MODULES) {
                GTNHModule.applyIfEnabled(moduleClass, this, project);
            }
        }

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ObjectFactory getObjectFactory();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ProviderFactory getProviderFactory();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ProjectLayout getProjectLayout();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull FileSystemOperations getFileSystemOperations();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ArchiveOperations getArchiveOperations();

        /** @return Gradle-provided injected service */
        @Inject
        public abstract @NotNull ExecOperations getExecOperations();
    }

    /**
     * The enum stored in the GTNHExtension object representing the selected MC version
     */
    public enum MinecraftVersion {

        V1_7_10("1.7.10", "10.13.4.1614", "stable", "12", UpdateableConstants.NEWEST_UNIMIXINS, UpdateableConstants.NEWEST_LWJGL3IFY),
        V1_12_2("1.12.2", "14.23.5.2847", "stable", "39", UpdateableConstants.NEWEST_MIXINBOOTER, UpdateableConstants.NEWEST_LWJGL3IFY_1122);

        private final String version;
        private final String forgeVersion;
        private final String mappingsChannel;
        private final String mappingsVersion;
        private final String mixinProviderSpec;
        private final String lwjgl3ifySpec;

        MinecraftVersion(String version, String forgeVersion, String mappingsChannel, String mappingsVersion, String mixinProviderSpec, String lwjgl3ifySpec) {
            this.version = version;
            this.forgeVersion = forgeVersion;
            this.mappingsChannel = mappingsChannel;
            this.mappingsVersion = mappingsVersion;
            this.mixinProviderSpec = mixinProviderSpec;
            this.lwjgl3ifySpec = lwjgl3ifySpec;
        }

        public String getVersion() {
            return version;
        }

        public String getForgeVersion() {
            return forgeVersion;
        }

        public String getMappingsChannel() {
            return mappingsChannel;
        }

        public String getMappingsVersion() {
            return mappingsVersion;
        }

        public String getMixinProviderSpec() {
            return mixinProviderSpec;
        }

        public String getLwjgl3ifySpec() {
            return lwjgl3ifySpec;
        }

        public static MinecraftVersion getByVersionString(String version) {
            for (MinecraftVersion v : MinecraftVersion.values()) {
                if (v.getVersion()
                    .equals(version)) {
                    return v;
                }
            }
            throw new IllegalArgumentException("Invalid Minecraft Version" + version);
        }
    }
}
